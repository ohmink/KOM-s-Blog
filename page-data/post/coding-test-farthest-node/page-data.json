{
    "componentChunkName": "component---src-pages-post-mdx-slug-js",
    "path": "/post/coding-test-farthest-node/",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"description\": \"프로그래머스 코딩테스트 그래프 가장 먼 노드\",\n  \"title\": \"[프로그래머스] 가장 먼 노드\",\n  \"tag\": [\"코딩테스트\"],\n  \"date\": \"2021-12-29\",\n  \"summary\": \"그래프가 주어졌을 때 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지 알아보자.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\uCF54\\uB529\\uD14C\\uC2A4\\uD2B8 \\uC5F0\\uC2B5 > \\uADF8\\uB798\\uD504 > \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://programmers.co.kr/learn/courses/30/lessons/49189\"\n  }, \"\\uAC00\\uC7A5 \\uBA3C \\uB178\\uB4DC\"))), mdx(\"h2\", null, \"\\uD480\\uC774\"), mdx(\"p\", null, \"Input\\uC73C\\uB85C \\uB4E4\\uC5B4\\uC624\\uB294 n\\uC73C\\uB85C \\uAC70\\uB9AC\\uB97C \\uC800\\uC7A5\\uD558\\uB294 \\uAC1D\\uCCB4\\uB97C \\uB9CC\\uB4E4\\uACE0, vertex\\uB97C BFS\\uB85C \\uD0D0\\uC0C9\\uD558\\uC5EC \\uAC70\\uB9AC\\uB97C \\uAD6C\\uD55C\\uB2E4.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC8FC\\uC758\\uD560 \\uC810\\uC740 vertex\\uC5D0 \\uC800\\uC7A5\\uB41C \", \"[a, b]\", \"\\uB294 \\uC591\\uBC29\\uD5A5 \\uAC04\\uC120\\uC774\\uBA70, a < b\\uAC00 \\uC544\\uB2C8\\uB77C\\uB294 \\uAC83\\uC774\\uB2E4.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uB530\\uB77C\\uC11C \\uD604\\uC7AC \\uB178\\uB4DC\\uAC00 a\\uC778\\uC9C0 b\\uC778\\uC9C0 \\uC54C\\uC544\\uC57C \\uD55C\\uB2E4.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function solution(n, vertex) {\\n    const distances = new Array(n).fill(0);\\n    const queue = [[1, 0]];\\n    let max = 0;\\n\\n    while (queue.length) {\\n        const [nodeId, len] = queue.shift();\\n\\n        for (const [a, b] of vertex) {\\n            if (a === nodeId && distances[b - 1] === 0){\\n                queue.push([b, len + 1]);\\n                distances[b - 1] = len + 1;\\n            } else if (b === nodeId && distances[a - 1] === 0) {\\n                queue.push([a, len + 1]);\\n                distances[a - 1] = len + 1;\\n            }\\n        }\\n\\n        if (max < len)\\n            max = len\\n    }\\n\\n    // \\uADF8\\uB798\\uD504\\uC5D0\\uC11C \\uC0AC\\uC774\\uD074\\uC774 \\uC774\\uB904\\uC9C0\\uB294 \\uACBD\\uC6B0 1\\uBC88 \\uB178\\uB4DC\\uC758 \\uAC70\\uB9AC\\uAC00 0\\uC774 \\uC544\\uB2CC \\uC218\\uB85C \\uBCC0\\uACBD\\uB41C\\uB2E4. \\uB530\\uB77C\\uC11C 0\\uC73C\\uB85C \\uCD08\\uAE30\\uD654\\n    distances[0] = 0;\\n    return distances.filter(dis => dis === max).length;\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"description":"프로그래머스 코딩테스트 그래프 가장 먼 노드","title":"[프로그래머스] 가장 먼 노드","date":"2021년 12월 29일","tag":["코딩테스트"]},"internal":{"content":"---\r\ndescription: \"프로그래머스 코딩테스트 그래프 가장 먼 노드\"\r\ntitle: \"[프로그래머스] 가장 먼 노드\"\r\ntag: [\"코딩테스트\"]\r\ndate: \"2021-12-29\"\r\nsummary: \"그래프가 주어졌을 때 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지 알아보자.\"\r\n---\r\n\r\n> 코딩테스트 연습 > 그래프 > [가장 먼 노드](https://programmers.co.kr/learn/courses/30/lessons/49189)\r\n\r\n## 풀이\r\n\r\nInput으로 들어오는 n으로 거리를 저장하는 객체를 만들고, vertex를 BFS로 탐색하여 거리를 구한다.\r\n\r\n- 주의할 점은 vertex에 저장된 [a, b]는 양방향 간선이며, a < b가 아니라는 것이다.\r\n- 따라서 현재 노드가 a인지 b인지 알아야 한다.\r\n\r\n```\r\nfunction solution(n, vertex) {\r\n    const distances = new Array(n).fill(0);\r\n    const queue = [[1, 0]];\r\n    let max = 0;\r\n\r\n    while (queue.length) {\r\n        const [nodeId, len] = queue.shift();\r\n\r\n        for (const [a, b] of vertex) {\r\n            if (a === nodeId && distances[b - 1] === 0){\r\n                queue.push([b, len + 1]);\r\n                distances[b - 1] = len + 1;\r\n            } else if (b === nodeId && distances[a - 1] === 0) {\r\n                queue.push([a, len + 1]);\r\n                distances[a - 1] = len + 1;\r\n            }\r\n        }\r\n\r\n        if (max < len)\r\n            max = len\r\n    }\r\n\r\n    // 그래프에서 사이클이 이뤄지는 경우 1번 노드의 거리가 0이 아닌 수로 변경된다. 따라서 0으로 초기화\r\n    distances[0] = 0;\r\n    return distances.filter(dis => dis === max).length;\r\n}\r\n```\r\n"}}},"pageContext":{"id":"da9be7b1-598b-5552-ad83-ff3ef8069bd4","slug":"coding-test-farthest-node","__params":{"slug":"coding-test-farthest-node"}}},
    "staticQueryHashes": ["1728580487","2841612589","3494247862"]}