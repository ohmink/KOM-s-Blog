{
    "componentChunkName": "component---src-pages-post-mdx-slug-js",
    "path": "/post/coding-test-palindrome/",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"description\": \"프로그래머스 코딩테스트 연습문제 가장 긴 팰린드롬\",\n  \"title\": \"[프로그래머스] 가장 긴 팰린드롬\",\n  \"tag\": [\"코딩테스트\"],\n  \"date\": \"2021-12-29\",\n  \"summary\": \"앞뒤를 뒤집어도 똑같은 문자열을 팰린드롬(palindrome)이라고 합니다. 문자열 s가 주어질 때, s의 부분문자열(Substring)중 가장 긴 팰린드롬의 길이를 return 하는 solution 함수를 완성해 주세요.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\uCF54\\uB529\\uD14C\\uC2A4\\uD2B8 \\uC5F0\\uC2B5 > \\uC5F0\\uC2B5\\uBB38\\uC81C > \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://programmers.co.kr/learn/courses/30/lessons/12904\"\n  }, \"\\uAC00\\uC7A5 \\uAE34 \\uD330\\uB9B0\\uB4DC\\uB86C\"))), mdx(\"h2\", null, \"\\uD480\\uC774\"), mdx(\"p\", null, \"\\uD330\\uB9B0\\uB4DC\\uB86C\\uC740 \\uC55E\\uB4A4\\uB97C \\uB4A4\\uC9D1\\uC5B4\\uB3C4 \\uB611\\uAC19\\uC740 \\uBB38\\uC790\\uC5F4\\uB85C, \\uB2E4\\uB978 \\uB9D0\\uB85C \\uD45C\\uD604\\uD558\\uBA74 \\uC88C\\uC6B0\\uB85C \\uC808\\uBC18\\uC744 \\uB098\\uB234\\uC744 \\uB54C \\uC67C\\uCABD = \\uB4A4\\uC9D1\\uC740 \\uC624\\uB978\\uCABD\\uC774\\uB77C\\uB294 \\uB73B\\uC774\\uB2E4.\\n\\uB530\\uB77C\\uC11C \\uCD5C\\uB300 \\uAE38\\uC774\\uC758 \\uC808\\uBC18\\uC744 \\uC2DC\\uC791\\uC73C\\uB85C \\uD558\\uB098\\uC529 \\uC904\\uC5EC\\uAC00\\uBA70 \\uBB38\\uC790\\uC5F4\\uC744 \\uD0D0\\uC0C9\\uD558\\uB294 \\uAC83\\uC73C\\uB85C \\uCC3E\\uC744 \\uC218 \\uC788\\uB2E4.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\uC8FC\\uC758\\uD560 \\uC810\\uC740 \\uC55E\\uB4A4\\uC758 \\uB3D9\\uC77C \\uC5EC\\uBD80\\uB97C \\uD310\\uBCC4\\uD560 \\uB54C \\uAC00\\uC6B4\\uB370 \\uBB38\\uC790 \\uD558\\uB098\\uAC00 \\uC788\\uC5B4\\uB3C4 \\uBB34\\uBC29\\uD558\\uB2E4\\uB294 \\uAC83.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"ex) abccba\\uB3C4 \\uD330\\uB9B0\\uB4DC\\uB86C\\uC774\\uACE0, abcXcba\\uB3C4 \\uD330\\uB9B0\\uB4DC\\uB86C\\uC774\\uB2E4. \\uD6C4\\uC790\\uAC00 \\uBB38\\uC790\\uC5F4\\uC758 \\uAE38\\uC774\\uAC00 \\uB354 \\uAE38\\uB2E4.\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"function solution(s) {\\n    function isPalindrome(str1, str2) {\\n        for (let i = 0; i < str1.length; i++)\\n            if (str1[i] !== str2[str2.length - (i + 1)])\\n                return false;\\n\\n        return true;\\n    }\\n\\n    let answer = 1;\\n    let len = Math.floor(s.length / 2);\\n\\n    for (let i = len; i > 0; i--) { // \\uCD5C\\uB300 \\uAE38\\uC774\\uC758 \\uC808\\uBC18\\uC744 \\uC2DC\\uC791\\uC73C\\uB85C 1\\uAE4C\\uC9C0 \\uC904\\uC5EC\\uAC04\\uB2E4.\\n        for (let j = 0; j <= s.length - i; j++) { // \\uBB38\\uC790\\uC5F4 s\\uC758 \\uCCAB \\uBC88\\uC9F8 \\uBB38\\uC790\\uB97C \\uC2DC\\uC791\\uC73C\\uB85C \\uC624\\uB978\\uCABD\\uC73C\\uB85C \\uD55C \\uCE78\\uC529 \\uC774\\uB3D9\\uD55C\\uB2E4.\\n            const left = s.slice(j, i + j);\\n            const right1 = s.slice(i + j, i * 2 + j);\\n\\n            if (i * 2 + j + 1 <= s.length) { // \\uC67C\\uCABD\\uACFC \\uC624\\uB978\\uCABD \\uAC00\\uC6B4\\uB370\\uC5D0 \\uBB38\\uC790 \\uD558\\uB098\\uB97C \\uB084 \\uC218 \\uC788\\uB2E4\\uBA74\\n                const right2 = s.slice(i + j + 1, i * 2 + j + 1);\\n\\n                if (isPalindrome(left, right2) && answer < left.length * 2 + 1)\\n                    answer = left.length * 2 + 1;\\n            }\\n\\n            if (isPalindrome(left, right1) && answer < left.length * 2)\\n                answer = left.length * 2;\\n        }\\n\\n        if (answer > 1)\\n            break;\\n    }\\n\\n    return answer;\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"description":"프로그래머스 코딩테스트 연습문제 가장 긴 팰린드롬","title":"[프로그래머스] 가장 긴 팰린드롬","date":"2021년 12월 29일","tag":["코딩테스트"]},"internal":{"content":"---\r\ndescription: \"프로그래머스 코딩테스트 연습문제 가장 긴 팰린드롬\"\r\ntitle: \"[프로그래머스] 가장 긴 팰린드롬\"\r\ntag: [\"코딩테스트\"]\r\ndate: \"2021-12-29\"\r\nsummary: \"앞뒤를 뒤집어도 똑같은 문자열을 팰린드롬(palindrome)이라고 합니다. 문자열 s가 주어질 때, s의 부분문자열(Substring)중 가장 긴 팰린드롬의 길이를 return 하는 solution 함수를 완성해 주세요.\"\r\n---\r\n\r\n> 코딩테스트 연습 > 연습문제 > [가장 긴 팰린드롬](https://programmers.co.kr/learn/courses/30/lessons/12904)\r\n\r\n## 풀이\r\n\r\n팰린드롬은 앞뒤를 뒤집어도 똑같은 문자열로, 다른 말로 표현하면 좌우로 절반을 나눴을 때 왼쪽 = 뒤집은 오른쪽이라는 뜻이다.\r\n따라서 최대 길이의 절반을 시작으로 하나씩 줄여가며 문자열을 탐색하는 것으로 찾을 수 있다.\r\n\r\n- 주의할 점은 앞뒤의 동일 여부를 판별할 때 가운데 문자 하나가 있어도 무방하다는 것.\r\n- ex) abccba도 팰린드롬이고, abcXcba도 팰린드롬이다. 후자가 문자열의 길이가 더 길다.\r\n\r\n```\r\nfunction solution(s) {\r\n    function isPalindrome(str1, str2) {\r\n        for (let i = 0; i < str1.length; i++)\r\n            if (str1[i] !== str2[str2.length - (i + 1)])\r\n                return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    let answer = 1;\r\n    let len = Math.floor(s.length / 2);\r\n\r\n    for (let i = len; i > 0; i--) { // 최대 길이의 절반을 시작으로 1까지 줄여간다.\r\n        for (let j = 0; j <= s.length - i; j++) { // 문자열 s의 첫 번째 문자를 시작으로 오른쪽으로 한 칸씩 이동한다.\r\n            const left = s.slice(j, i + j);\r\n            const right1 = s.slice(i + j, i * 2 + j);\r\n\r\n            if (i * 2 + j + 1 <= s.length) { // 왼쪽과 오른쪽 가운데에 문자 하나를 낄 수 있다면\r\n                const right2 = s.slice(i + j + 1, i * 2 + j + 1);\r\n\r\n                if (isPalindrome(left, right2) && answer < left.length * 2 + 1)\r\n                    answer = left.length * 2 + 1;\r\n            }\r\n\r\n            if (isPalindrome(left, right1) && answer < left.length * 2)\r\n                answer = left.length * 2;\r\n        }\r\n\r\n        if (answer > 1)\r\n            break;\r\n    }\r\n\r\n    return answer;\r\n}\r\n```\r\n"}}},"pageContext":{"id":"81334d5e-ccfe-523c-9e71-49fceb13ebe9","slug":"coding-test-palindrome","__params":{"slug":"coding-test-palindrome"}}},
    "staticQueryHashes": ["1728580487","2841612589","3494247862"]}