---
description: "TCP의 특징과 연결 생성 3-way handshake와 연결 해제 4-way handshake에 대해 정리한 문서"
title: "TCP에 대하여"
tag: ["CS", "네트워크"]
date: "2021-05-24"
summary: "TCP의 특징과 연결 생성 3-way handshake, 연결 해제 4-way handshake에 대해 정리해보자"
---

> [위키백과](https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EC%A0%9C%EC%96%B4_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C), 최희준 교수님의 [영상 자료](https://www.youtube.com/watch?v=Fh1GAi63CfA),
> [Evan Moon님](https://evan-moon.github.io/2019/11/17/tcp-handshake/#established%EC%88%98%EC%8B%A0%EC%9E%90), [정보통신기술용어해설](http://www.ktword.co.kr/abbr_view.php?nav=2&id=995) 등을 보고 공부한 걸 정리했습니다.

# 특징

- **전송** 데이터의 `흐름을 제어`하고 데이터의 `에러 유무를 검사`, `오버플로우 등을 방지`한다.
  > - 흐름 제어, 오류 검출, 혼잡 제어 -> 전송 계층의 역할
- 두 종단 간의 연결을 설정하고 데이터를 패킷 단위로 교환
- 수신 측에서는 패킷이 잘못 왔을 경우 재전송을 요구
- 데이터 전송 프로토콜로 `연결형(접속형)` 프로토콜이다.
  > - 연결형이기 때문에 상대방과 연결이 된 경우에만 데이터를 교환
  > - 상대방을 찾는 역할은 IP 프로토콜이 하는데, 이 때문에 TCP/IP 프로토콜이라 같이 부르는 경우가 많다.

# 연결의 생성과 해제

- 통신하기 전에 반드시 상대방과의 `연결을 생성(수립)`하고, 통신을 안전하게 종료하기 위해서 `연결을 해제`하는 과정을 거친다.
- 이와 같은 과정을 수행하기 때문에 `신뢰성이 높지만 지연시간이 발생`한다.

## 연결 생성(3 way handshake)

- 순서 번호(SYN-제어비트 중 하나-, Sequence Number)와 확인응답(ACK-제어비트 중 하나-, Acknowledgement Number)를 이용
- 아래에서 상태가 의미하는 건 포트의 상태다.

### 주요 목적

- 연결이 시작됨과 옵션이 교환됐음을 알림
- ISN(랜덤한 초기 순서번호)를 생성하고 교환했음을 알림
  - 순서번호 초기화 직후 상대와의 순서번호 동기화 목적

### 연결 과정에서 교환되는 정보

- ISN
- rwnd(수신 기본 윈도우 크기)
- 옵션 정보(MSS, SACK 옵션, 추가 윈도우 스케일 옵션)

### 흐름

1. A(Client) -> B(Server) - 클라이언트(A)는 서버(B)에게 `SYN 패킷을 전송`한다. - `클라이언트`는 `CLOSED 상태`에서 서버의 응답(SYN + ACK 패킷)을 기다리는 `SYN_SENT 상태`로 변경 - SYN 패킷이 도착하기 전까지 `서버는 LISTEN 상태 - 시퀀스 넘버는 전송 측에서 임의로 결정
   > A가 B에게, 나 너랑 통신하고 싶어!
2. B -> A - 서버(B)가 클라이언트(A)에게 `SYN + ACK 패킷을 전송`한다. - 서버는 SYN_RECEIVED 상태 - 클라이언트는 이 응답을 받으면 `SYN_SENT 상태`에서 `ESTABLISHED 상태`로 변경 - 서버가 보낸 패킷의 시퀀스 넘버는 임의, ACK 넘버는 클라이언트가 보낸 패킷의 시퀀스 넘버+1이다.
   > B가 A에게, 그래? 그러면 그럼 너도 포트 열어.
3. A -> B - 클라이언트(A)가 서버(B)에게 `ACK 패킷을 전송`한다. - 이 패킷은 최종적으로 수락하고 연결을 생성한다는 의미 - ACK 패킷을 보낼 때 전송할 데이터가 있다면 이 단계에서 데이터를 전송할 수 있다. - 서버, 클라이언트 모두 `ESTABLISHED 상태`
   > A가 B에게, 열었어! 통신하자!

## 연결 해제(4 way handshake)

- TCP의 연결을 해제하는 과정
- 연결을 종료하기 전에 끝내지 못한 작업이 있을 수 있기에, 혹은 서로에게 연결 해제를 알리는 의미(그냥 끊어버리면 상대편은 연결이 종료되었는지 알 수 없다.)

### 특징

- TCP 연결 종료는 양방향 2개 연결을 각 측이 독립적으로 닫게 됨
  - `FIN 및 그에대한 FIN-ACK`의 1쌍 씩 2개. 즉, 4개(4 way)로 종료한다.
- TCP 연결 생성보다 복잡
  - 한쪽이 CLOSED되어도 다른 한쪽은 아니거나
  - 데드락이 걸리거나
  - 타임아웃이 존재하지 않는 경우 무한정 기다리게 되거나 등
  - 다양한 상황이 발생할 수 있다.

### 연결 종료 구분

- 정상 종료(Normal Close)
  - 4 way handshake로 양방향 모두 종료되는 것
  - 이게 보통일 것 같았으나 정상 종료보다 반 종료가 더 일반적이라고 한다.
- 반 종료(Half Close)
  - 양쪽 회선을 모두 종료하지 않고, 한쪽 회선은 열어두는 것.
  - 수신은 열어두고 송신을 닫거나, 수신을 닫고 송신을 열어두는
  - 보내지 못했거나 받지 못한 데이터가 있으면 이 기법을 이용하여 모두 처리하고 나머지 반을 닫는 것으로 보다 안전하게 연결을 종료한다.
- 동시 종료
  - 거의 동시에 양측에서 FIN 세그먼트를 보내는 경우
- 강제 종료
  - TCP Reset 요구(RESET 세그먼트) 기능

### 흐름

1. A -> B
   - 클라이언트가 서버에게 `FIN 패킷을 전송`한다.
   - 보내고 연결을 끊어버리는 게 아니라, 클라이언트는 B가 응답하기 전까지 대기한다. 따라서 `클라이언트는 FIN_WAIT1 상태`
     > Seq : K, Ack : -
2. B -> A

   - 서버가 클라이언트에게 `ACK 패킷을 전송`한다.
   - `ACK`는 요청자(클라이언트, A)가 보낸 `시퀀스 번호 + 1`
   - 전송 후 `서버는 CLOSED_WAIT 상태`
   - 이 단계 이후 B는 A에게 보낼 데이터가 남아있다면 이어서 전송하고, 이후 명시적으로 close()나 shutdown() 같은 함수를 사용하여 다음 단계(3)로 넘어갈 것이다.
     > Seq : L, Ack : K + 1

   `이 과정에서 명시적 함수 호출을 하지 않아 다음 단계로 넘어가지 않을 경우, A측은 무작정 B의 통신을 기다리게 될 것이고(타임아웃을 사용하여 방지), B는 현 단계에서 멈춰버린 상태가 될 수도 있다.(데드락)`

3. B -> A
   - 서버가 클라이언트에게 `FIN 패킷을 전송`한다. (종료를 알린다.)
   - 시퀀스 넘버와 ACK 넘버는 이전 것들을 사용한다.
   - 서버는 `LAST_ACK 상태`
   - 클라이언트는 이 패킷을 받은 후 `TIME_WAIT 상태`
   - 클라이언트의 TIME_WAIT는 데드락에 빠지는 걸 방지하기 위해 동작
     > Seq : L, Ack : K + 1
4. A -> B
   - 클라이언트가 서버에게 `ACK 패킷을 전송`한다. (확인 메시지)
   - ACK 넘버는 3단계에서 받은 시퀀스 번호 + 1
   - 클라이언트 TIME_WAIT에서 최대 세그먼트 수명(MSL)의 두 배를 기다리다가 CLOSED 된다.
   - 클라이언트는 `CLOSED` 상태
   - 이 메시지를 받은 후 서버도 `CLOSED` 상태
     > Seq : K, Ack : L + 1

# 종합

TCP는 안정적이고 연결지향적인 트랜스포트 계층용 프로토콜이다.

- 전송 계층의 역할(흐름 제어, 혼잡 제어, 오류 검출 등)
- 3단계 핸드세이킹 과정을 밟고 통신을 연결(ESTABLISHED)
- 해당 세션에서 데이터 전송을 완료한 후
- 4단계 핸드세이킹 과정을 밟고 통신을 종료(CLOSED)
- 안정적이고 신뢰성이 보장되지만 이러한 절차들 때문에 속도가 상대적으로 느리다.(지연시간이 발생한다.)
